// Code generated by MockGen. DO NOT EDIT.
// Source: kaiax/interface.go

// Package mock_kaiax is a generated GoMock package.
package mock_kaiax

import (
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	state "github.com/kaiachain/kaia/blockchain/state"
	types "github.com/kaiachain/kaia/blockchain/types"
	vm "github.com/kaiachain/kaia/blockchain/vm"
	common "github.com/kaiachain/kaia/common"
	kaiax "github.com/kaiachain/kaia/kaiax"
	rpc "github.com/kaiachain/kaia/networks/rpc"
)

// MockBaseModule is a mock of BaseModule interface.
type MockBaseModule struct {
	ctrl     *gomock.Controller
	recorder *MockBaseModuleMockRecorder
}

// MockBaseModuleMockRecorder is the mock recorder for MockBaseModule.
type MockBaseModuleMockRecorder struct {
	mock *MockBaseModule
}

// NewMockBaseModule creates a new mock instance.
func NewMockBaseModule(ctrl *gomock.Controller) *MockBaseModule {
	mock := &MockBaseModule{ctrl: ctrl}
	mock.recorder = &MockBaseModuleMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBaseModule) EXPECT() *MockBaseModuleMockRecorder {
	return m.recorder
}

// Start mocks base method.
func (m *MockBaseModule) Start() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start")
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockBaseModuleMockRecorder) Start() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockBaseModule)(nil).Start))
}

// Stop mocks base method.
func (m *MockBaseModule) Stop() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Stop")
}

// Stop indicates an expected call of Stop.
func (mr *MockBaseModuleMockRecorder) Stop() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockBaseModule)(nil).Stop))
}

// MockJsonRpcModule is a mock of JsonRpcModule interface.
type MockJsonRpcModule struct {
	ctrl     *gomock.Controller
	recorder *MockJsonRpcModuleMockRecorder
}

// MockJsonRpcModuleMockRecorder is the mock recorder for MockJsonRpcModule.
type MockJsonRpcModuleMockRecorder struct {
	mock *MockJsonRpcModule
}

// NewMockJsonRpcModule creates a new mock instance.
func NewMockJsonRpcModule(ctrl *gomock.Controller) *MockJsonRpcModule {
	mock := &MockJsonRpcModule{ctrl: ctrl}
	mock.recorder = &MockJsonRpcModuleMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJsonRpcModule) EXPECT() *MockJsonRpcModuleMockRecorder {
	return m.recorder
}

// APIs mocks base method.
func (m *MockJsonRpcModule) APIs() []rpc.API {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "APIs")
	ret0, _ := ret[0].([]rpc.API)
	return ret0
}

// APIs indicates an expected call of APIs.
func (mr *MockJsonRpcModuleMockRecorder) APIs() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "APIs", reflect.TypeOf((*MockJsonRpcModule)(nil).APIs))
}

// MockConsensusModule is a mock of ConsensusModule interface.
type MockConsensusModule struct {
	ctrl     *gomock.Controller
	recorder *MockConsensusModuleMockRecorder
}

// MockConsensusModuleMockRecorder is the mock recorder for MockConsensusModule.
type MockConsensusModuleMockRecorder struct {
	mock *MockConsensusModule
}

// NewMockConsensusModule creates a new mock instance.
func NewMockConsensusModule(ctrl *gomock.Controller) *MockConsensusModule {
	mock := &MockConsensusModule{ctrl: ctrl}
	mock.recorder = &MockConsensusModuleMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConsensusModule) EXPECT() *MockConsensusModuleMockRecorder {
	return m.recorder
}

// FinalizeHeader mocks base method.
func (m *MockConsensusModule) FinalizeHeader(header *types.Header, state *state.StateDB, txs []*types.Transaction, receipts []*types.Receipt) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FinalizeHeader", header, state, txs, receipts)
	ret0, _ := ret[0].(error)
	return ret0
}

// FinalizeHeader indicates an expected call of FinalizeHeader.
func (mr *MockConsensusModuleMockRecorder) FinalizeHeader(header, state, txs, receipts interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FinalizeHeader", reflect.TypeOf((*MockConsensusModule)(nil).FinalizeHeader), header, state, txs, receipts)
}

// PrepareHeader mocks base method.
func (m *MockConsensusModule) PrepareHeader(header *types.Header) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PrepareHeader", header)
	ret0, _ := ret[0].(error)
	return ret0
}

// PrepareHeader indicates an expected call of PrepareHeader.
func (mr *MockConsensusModuleMockRecorder) PrepareHeader(header interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrepareHeader", reflect.TypeOf((*MockConsensusModule)(nil).PrepareHeader), header)
}

// VerifyHeader mocks base method.
func (m *MockConsensusModule) VerifyHeader(header *types.Header) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VerifyHeader", header)
	ret0, _ := ret[0].(error)
	return ret0
}

// VerifyHeader indicates an expected call of VerifyHeader.
func (mr *MockConsensusModuleMockRecorder) VerifyHeader(header interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VerifyHeader", reflect.TypeOf((*MockConsensusModule)(nil).VerifyHeader), header)
}

// MockConsensusModuleHost is a mock of ConsensusModuleHost interface.
type MockConsensusModuleHost struct {
	ctrl     *gomock.Controller
	recorder *MockConsensusModuleHostMockRecorder
}

// MockConsensusModuleHostMockRecorder is the mock recorder for MockConsensusModuleHost.
type MockConsensusModuleHostMockRecorder struct {
	mock *MockConsensusModuleHost
}

// NewMockConsensusModuleHost creates a new mock instance.
func NewMockConsensusModuleHost(ctrl *gomock.Controller) *MockConsensusModuleHost {
	mock := &MockConsensusModuleHost{ctrl: ctrl}
	mock.recorder = &MockConsensusModuleHostMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConsensusModuleHost) EXPECT() *MockConsensusModuleHostMockRecorder {
	return m.recorder
}

// RegisterConsensusModule mocks base method.
func (m *MockConsensusModuleHost) RegisterConsensusModule(modules ...kaiax.ConsensusModule) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range modules {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "RegisterConsensusModule", varargs...)
}

// RegisterConsensusModule indicates an expected call of RegisterConsensusModule.
func (mr *MockConsensusModuleHostMockRecorder) RegisterConsensusModule(modules ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterConsensusModule", reflect.TypeOf((*MockConsensusModuleHost)(nil).RegisterConsensusModule), modules...)
}

// UnregisterConsensusModule mocks base method.
func (m *MockConsensusModuleHost) UnregisterConsensusModule(module kaiax.ConsensusModule) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "UnregisterConsensusModule", module)
}

// UnregisterConsensusModule indicates an expected call of UnregisterConsensusModule.
func (mr *MockConsensusModuleHostMockRecorder) UnregisterConsensusModule(module interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnregisterConsensusModule", reflect.TypeOf((*MockConsensusModuleHost)(nil).UnregisterConsensusModule), module)
}

// MockExecutionModule is a mock of ExecutionModule interface.
type MockExecutionModule struct {
	ctrl     *gomock.Controller
	recorder *MockExecutionModuleMockRecorder
}

// MockExecutionModuleMockRecorder is the mock recorder for MockExecutionModule.
type MockExecutionModuleMockRecorder struct {
	mock *MockExecutionModule
}

// NewMockExecutionModule creates a new mock instance.
func NewMockExecutionModule(ctrl *gomock.Controller) *MockExecutionModule {
	mock := &MockExecutionModule{ctrl: ctrl}
	mock.recorder = &MockExecutionModuleMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExecutionModule) EXPECT() *MockExecutionModuleMockRecorder {
	return m.recorder
}

// PostInsertBlock mocks base method.
func (m *MockExecutionModule) PostInsertBlock(block *types.Block) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PostInsertBlock", block)
	ret0, _ := ret[0].(error)
	return ret0
}

// PostInsertBlock indicates an expected call of PostInsertBlock.
func (mr *MockExecutionModuleMockRecorder) PostInsertBlock(block interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PostInsertBlock", reflect.TypeOf((*MockExecutionModule)(nil).PostInsertBlock), block)
}

// MockExecutionModuleHost is a mock of ExecutionModuleHost interface.
type MockExecutionModuleHost struct {
	ctrl     *gomock.Controller
	recorder *MockExecutionModuleHostMockRecorder
}

// MockExecutionModuleHostMockRecorder is the mock recorder for MockExecutionModuleHost.
type MockExecutionModuleHostMockRecorder struct {
	mock *MockExecutionModuleHost
}

// NewMockExecutionModuleHost creates a new mock instance.
func NewMockExecutionModuleHost(ctrl *gomock.Controller) *MockExecutionModuleHost {
	mock := &MockExecutionModuleHost{ctrl: ctrl}
	mock.recorder = &MockExecutionModuleHostMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExecutionModuleHost) EXPECT() *MockExecutionModuleHostMockRecorder {
	return m.recorder
}

// RegisterExecutionModule mocks base method.
func (m *MockExecutionModuleHost) RegisterExecutionModule(modules ...kaiax.ExecutionModule) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range modules {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "RegisterExecutionModule", varargs...)
}

// RegisterExecutionModule indicates an expected call of RegisterExecutionModule.
func (mr *MockExecutionModuleHostMockRecorder) RegisterExecutionModule(modules ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterExecutionModule", reflect.TypeOf((*MockExecutionModuleHost)(nil).RegisterExecutionModule), modules...)
}

// MockRewindableModule is a mock of RewindableModule interface.
type MockRewindableModule struct {
	ctrl     *gomock.Controller
	recorder *MockRewindableModuleMockRecorder
}

// MockRewindableModuleMockRecorder is the mock recorder for MockRewindableModule.
type MockRewindableModuleMockRecorder struct {
	mock *MockRewindableModule
}

// NewMockRewindableModule creates a new mock instance.
func NewMockRewindableModule(ctrl *gomock.Controller) *MockRewindableModule {
	mock := &MockRewindableModule{ctrl: ctrl}
	mock.recorder = &MockRewindableModuleMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRewindableModule) EXPECT() *MockRewindableModuleMockRecorder {
	return m.recorder
}

// RewindDelete mocks base method.
func (m *MockRewindableModule) RewindDelete(hash common.Hash, num uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RewindDelete", hash, num)
}

// RewindDelete indicates an expected call of RewindDelete.
func (mr *MockRewindableModuleMockRecorder) RewindDelete(hash, num interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RewindDelete", reflect.TypeOf((*MockRewindableModule)(nil).RewindDelete), hash, num)
}

// RewindTo mocks base method.
func (m *MockRewindableModule) RewindTo(newBlock *types.Block) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RewindTo", newBlock)
}

// RewindTo indicates an expected call of RewindTo.
func (mr *MockRewindableModuleMockRecorder) RewindTo(newBlock interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RewindTo", reflect.TypeOf((*MockRewindableModule)(nil).RewindTo), newBlock)
}

// Start mocks base method.
func (m *MockRewindableModule) Start() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start")
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockRewindableModuleMockRecorder) Start() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockRewindableModule)(nil).Start))
}

// Stop mocks base method.
func (m *MockRewindableModule) Stop() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Stop")
}

// Stop indicates an expected call of Stop.
func (mr *MockRewindableModuleMockRecorder) Stop() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockRewindableModule)(nil).Stop))
}

// MockRewindableModuleHost is a mock of RewindableModuleHost interface.
type MockRewindableModuleHost struct {
	ctrl     *gomock.Controller
	recorder *MockRewindableModuleHostMockRecorder
}

// MockRewindableModuleHostMockRecorder is the mock recorder for MockRewindableModuleHost.
type MockRewindableModuleHostMockRecorder struct {
	mock *MockRewindableModuleHost
}

// NewMockRewindableModuleHost creates a new mock instance.
func NewMockRewindableModuleHost(ctrl *gomock.Controller) *MockRewindableModuleHost {
	mock := &MockRewindableModuleHost{ctrl: ctrl}
	mock.recorder = &MockRewindableModuleHostMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRewindableModuleHost) EXPECT() *MockRewindableModuleHostMockRecorder {
	return m.recorder
}

// RegisterRewindableModule mocks base method.
func (m *MockRewindableModuleHost) RegisterRewindableModule(modules ...kaiax.RewindableModule) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range modules {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "RegisterRewindableModule", varargs...)
}

// RegisterRewindableModule indicates an expected call of RegisterRewindableModule.
func (mr *MockRewindableModuleHostMockRecorder) RegisterRewindableModule(modules ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterRewindableModule", reflect.TypeOf((*MockRewindableModuleHost)(nil).RegisterRewindableModule), modules...)
}

// MockTxProcessModule is a mock of TxProcessModule interface.
type MockTxProcessModule struct {
	ctrl     *gomock.Controller
	recorder *MockTxProcessModuleMockRecorder
}

// MockTxProcessModuleMockRecorder is the mock recorder for MockTxProcessModule.
type MockTxProcessModuleMockRecorder struct {
	mock *MockTxProcessModule
}

// NewMockTxProcessModule creates a new mock instance.
func NewMockTxProcessModule(ctrl *gomock.Controller) *MockTxProcessModule {
	mock := &MockTxProcessModule{ctrl: ctrl}
	mock.recorder = &MockTxProcessModuleMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTxProcessModule) EXPECT() *MockTxProcessModuleMockRecorder {
	return m.recorder
}

// PostRunTx mocks base method.
func (m *MockTxProcessModule) PostRunTx(evm *vm.EVM, tx *types.Transaction) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PostRunTx", evm, tx)
	ret0, _ := ret[0].(error)
	return ret0
}

// PostRunTx indicates an expected call of PostRunTx.
func (mr *MockTxProcessModuleMockRecorder) PostRunTx(evm, tx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PostRunTx", reflect.TypeOf((*MockTxProcessModule)(nil).PostRunTx), evm, tx)
}

// PreRunTx mocks base method.
func (m *MockTxProcessModule) PreRunTx(evm *vm.EVM, tx *types.Transaction) (*types.Transaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PreRunTx", evm, tx)
	ret0, _ := ret[0].(*types.Transaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PreRunTx indicates an expected call of PreRunTx.
func (mr *MockTxProcessModuleMockRecorder) PreRunTx(evm, tx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PreRunTx", reflect.TypeOf((*MockTxProcessModule)(nil).PreRunTx), evm, tx)
}

// MockTxProcessModuleHost is a mock of TxProcessModuleHost interface.
type MockTxProcessModuleHost struct {
	ctrl     *gomock.Controller
	recorder *MockTxProcessModuleHostMockRecorder
}

// MockTxProcessModuleHostMockRecorder is the mock recorder for MockTxProcessModuleHost.
type MockTxProcessModuleHostMockRecorder struct {
	mock *MockTxProcessModuleHost
}

// NewMockTxProcessModuleHost creates a new mock instance.
func NewMockTxProcessModuleHost(ctrl *gomock.Controller) *MockTxProcessModuleHost {
	mock := &MockTxProcessModuleHost{ctrl: ctrl}
	mock.recorder = &MockTxProcessModuleHostMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTxProcessModuleHost) EXPECT() *MockTxProcessModuleHostMockRecorder {
	return m.recorder
}

// RegisterTxProcessModule mocks base method.
func (m *MockTxProcessModuleHost) RegisterTxProcessModule(modules ...kaiax.TxProcessModule) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range modules {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "RegisterTxProcessModule", varargs...)
}

// RegisterTxProcessModule indicates an expected call of RegisterTxProcessModule.
func (mr *MockTxProcessModuleHostMockRecorder) RegisterTxProcessModule(modules ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterTxProcessModule", reflect.TypeOf((*MockTxProcessModuleHost)(nil).RegisterTxProcessModule), modules...)
}

// MockTxPoolModule is a mock of TxPoolModule interface.
type MockTxPoolModule struct {
	ctrl     *gomock.Controller
	recorder *MockTxPoolModuleMockRecorder
}

// MockTxPoolModuleMockRecorder is the mock recorder for MockTxPoolModule.
type MockTxPoolModuleMockRecorder struct {
	mock *MockTxPoolModule
}

// NewMockTxPoolModule creates a new mock instance.
func NewMockTxPoolModule(ctrl *gomock.Controller) *MockTxPoolModule {
	mock := &MockTxPoolModule{ctrl: ctrl}
	mock.recorder = &MockTxPoolModuleMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTxPoolModule) EXPECT() *MockTxPoolModuleMockRecorder {
	return m.recorder
}

// GetCheckBalance mocks base method.
func (m *MockTxPoolModule) GetCheckBalance() func(kaiax.TxPool, *types.Transaction) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCheckBalance")
	ret0, _ := ret[0].(func(kaiax.TxPool, *types.Transaction) error)
	return ret0
}

// GetCheckBalance indicates an expected call of GetCheckBalance.
func (mr *MockTxPoolModuleMockRecorder) GetCheckBalance() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCheckBalance", reflect.TypeOf((*MockTxPoolModule)(nil).GetCheckBalance))
}

// IsModuleTx mocks base method.
func (m *MockTxPoolModule) IsModuleTx(pool kaiax.TxPool, tx *types.Transaction) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsModuleTx", pool, tx)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsModuleTx indicates an expected call of IsModuleTx.
func (mr *MockTxPoolModuleMockRecorder) IsModuleTx(pool, tx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsModuleTx", reflect.TypeOf((*MockTxPoolModule)(nil).IsModuleTx), pool, tx)
}

// IsReady mocks base method.
func (m *MockTxPoolModule) IsReady(pool kaiax.TxPool, txs map[uint64]*types.Transaction, next uint64, ready types.Transactions) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsReady", pool, txs, next, ready)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsReady indicates an expected call of IsReady.
func (mr *MockTxPoolModuleMockRecorder) IsReady(pool, txs, next, ready interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsReady", reflect.TypeOf((*MockTxPoolModule)(nil).IsReady), pool, txs, next, ready)
}

// PreAddLocal mocks base method.
func (m *MockTxPoolModule) PreAddLocal(arg0 *types.Transaction) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PreAddLocal", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// PreAddLocal indicates an expected call of PreAddLocal.
func (mr *MockTxPoolModuleMockRecorder) PreAddLocal(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PreAddLocal", reflect.TypeOf((*MockTxPoolModule)(nil).PreAddLocal), arg0)
}

// PreAddRemote mocks base method.
func (m *MockTxPoolModule) PreAddRemote(arg0 *types.Transaction) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PreAddRemote", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// PreAddRemote indicates an expected call of PreAddRemote.
func (mr *MockTxPoolModuleMockRecorder) PreAddRemote(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PreAddRemote", reflect.TypeOf((*MockTxPoolModule)(nil).PreAddRemote), arg0)
}

// MockTxPoolModuleHost is a mock of TxPoolModuleHost interface.
type MockTxPoolModuleHost struct {
	ctrl     *gomock.Controller
	recorder *MockTxPoolModuleHostMockRecorder
}

// MockTxPoolModuleHostMockRecorder is the mock recorder for MockTxPoolModuleHost.
type MockTxPoolModuleHostMockRecorder struct {
	mock *MockTxPoolModuleHost
}

// NewMockTxPoolModuleHost creates a new mock instance.
func NewMockTxPoolModuleHost(ctrl *gomock.Controller) *MockTxPoolModuleHost {
	mock := &MockTxPoolModuleHost{ctrl: ctrl}
	mock.recorder = &MockTxPoolModuleHostMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTxPoolModuleHost) EXPECT() *MockTxPoolModuleHostMockRecorder {
	return m.recorder
}

// RegisterTxPoolModule mocks base method.
func (m *MockTxPoolModuleHost) RegisterTxPoolModule(modules ...kaiax.TxPoolModule) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range modules {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "RegisterTxPoolModule", varargs...)
}

// RegisterTxPoolModule indicates an expected call of RegisterTxPoolModule.
func (mr *MockTxPoolModuleHostMockRecorder) RegisterTxPoolModule(modules ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterTxPoolModule", reflect.TypeOf((*MockTxPoolModuleHost)(nil).RegisterTxPoolModule), modules...)
}

// MockTxPool is a mock of TxPool interface.
type MockTxPool struct {
	ctrl     *gomock.Controller
	recorder *MockTxPoolMockRecorder
}

// MockTxPoolMockRecorder is the mock recorder for MockTxPool.
type MockTxPoolMockRecorder struct {
	mock *MockTxPool
}

// NewMockTxPool creates a new mock instance.
func NewMockTxPool(ctrl *gomock.Controller) *MockTxPool {
	mock := &MockTxPool{ctrl: ctrl}
	mock.recorder = &MockTxPoolMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTxPool) EXPECT() *MockTxPoolMockRecorder {
	return m.recorder
}

// GetNonce mocks base method.
func (m *MockTxPool) GetNonce(addr common.Address) uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetNonce", addr)
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetNonce indicates an expected call of GetNonce.
func (mr *MockTxPoolMockRecorder) GetNonce(addr interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNonce", reflect.TypeOf((*MockTxPool)(nil).GetNonce), addr)
}
